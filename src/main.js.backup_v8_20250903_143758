import { invoke } from '@tauri-apps/api/tauri';
import { open } from '@tauri-apps/api/dialog';
import { readDir, readBinaryFile } from '@tauri-apps/api/fs';
import { convertFileSrc } from '@tauri-apps/api/tauri';
import localforage from 'localforage';

// ë¸Œëœë“œ ê°€ë°© íŠ¹í™” ê²€ìƒ‰ ì‹œìŠ¤í…œ v8.0
class BrandBagSearchSystem {
    constructor() {
        this.currentMode = 'search';
        this.uploadedImage = null;
        this.imageDatabase = [];
        this.version = '8.0.0';
        
        // LocalForage ì„¤ì •
        this.storage = localforage.createInstance({
            name: 'BrandBagDB',
            storeName: 'brandBagVectorsV8'
        });
        
        // ë¸Œëœë“œë³„ ì‹œê·¸ë‹ˆì²˜ íŒ¨í„´ ì •ì˜
        this.brandPatterns = {
            louis_vuitton: {
                colors: { brown: [101, 67, 33], beige: [196, 176, 144] },
                patterns: ['monogram', 'damier'],
                metalColors: ['gold'],
                aspectRatios: [1.0, 1.2, 1.5] // í† íŠ¸ë°±, ìŠ¤í”¼ë””ë°± ë“±
            },
            chanel: {
                colors: { black: [0, 0, 0], beige: [245, 245, 220] },
                patterns: ['quilted', 'diamond'],
                metalColors: ['gold', 'silver'],
                aspectRatios: [1.3, 1.5]
            },
            gucci: {
                colors: { green: [0, 100, 0], red: [200, 0, 0] },
                patterns: ['stripes', 'gg_pattern'],
                metalColors: ['gold'],
                aspectRatios: [1.0, 1.4]
            },
            prada: {
                colors: { black: [0, 0, 0], navy: [0, 0, 128] },
                patterns: ['triangle_logo', 'saffiano'],
                metalColors: ['silver'],
                aspectRatios: [1.2, 1.4]
            },
            hermes: {
                colors: { orange: [255, 140, 0], brown: [139, 69, 19] },
                patterns: ['smooth', 'grain'],
                metalColors: ['gold', 'palladium'],
                aspectRatios: [1.0, 1.3]
            }
        };
        
        console.log(`ğŸ‘œ Brand Bag Search v${this.version} - ë¸Œëœë“œ ê°€ë°© íŠ¹í™” ì‹œìŠ¤í…œ`);
        this.init();
    }

    async init() {
        console.log('âœ… ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì¤‘...');
        await this.loadDatabase();
        this.setupEventListeners();
        console.log('âœ… ì´ˆê¸°í™” ì™„ë£Œ!');
    }

    setupEventListeners() {
        console.log('ğŸ”§ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì • ì¤‘...');
        
        // ëª¨ë“œ ì „í™˜
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const mode = e.currentTarget.dataset.mode;
                this.switchMode(mode);
                console.log(`ëª¨ë“œ ì „í™˜: ${mode}`);
            });
        });

        // íŒŒì¼ ì—…ë¡œë“œ
        const uploadArea = document.getElementById('upload-area');
        const fileInput = document.getElementById('file-input');

        if (uploadArea && fileInput) {
            uploadArea.addEventListener('click', () => {
                console.log('ì—…ë¡œë“œ ì˜ì—­ í´ë¦­');
                fileInput.click();
            });
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });
            
            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].type.startsWith('image/')) {
                    this.handleImageUpload(files[0]);
                }
            });

            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    console.log('íŒŒì¼ ì„ íƒë¨:', file.name);
                    this.handleImageUpload(file);
                }
            });
        }

        // ê²€ìƒ‰ ë²„íŠ¼
        const searchBtn = document.getElementById('search-btn');
        if (searchBtn) {
            searchBtn.addEventListener('click', () => {
                console.log('ê²€ìƒ‰ ë²„íŠ¼ í´ë¦­');
                this.searchSimilarImages();
            });
        }

        // í´ë” ì„ íƒ ë²„íŠ¼
        const selectFolderBtn = document.getElementById('select-folder-btn');
        if (selectFolderBtn) {
            selectFolderBtn.addEventListener('click', () => {
                console.log('í´ë” ì„ íƒ ë²„íŠ¼ í´ë¦­');
                this.selectFolder();
            });
        }

        // ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™” ë²„íŠ¼
        const clearDbBtn = document.getElementById('clear-database-btn');
        if (clearDbBtn) {
            clearDbBtn.addEventListener('click', async () => {
                console.log('DB ì´ˆê¸°í™” ë²„íŠ¼ í´ë¦­');
                if (confirm('ëª¨ë“  ì¸ë±ì‹±ëœ ë°ì´í„°ê°€ ì‚­ì œë©ë‹ˆë‹¤. ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                    this.imageDatabase = [];
                    await this.storage.clear();
                    alert('ë°ì´í„°ë² ì´ìŠ¤ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.');
                    console.log('ğŸ—‘ï¸ ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™” ì™„ë£Œ');
                }
            });
        }
        
        console.log('âœ… ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì • ì™„ë£Œ');
    }

    switchMode(mode) {
        this.currentMode = mode;
        
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === mode);
        });

        document.querySelectorAll('.mode-content').forEach(content => {
            content.classList.remove('active');
        });
        
        const targetMode = document.getElementById(`${mode}-mode`);
        if (targetMode) {
            targetMode.classList.add('active');
        }
    }

    async handleImageUpload(file) {
        const reader = new FileReader();
        reader.onload = async (e) => {
            const img = new Image();
            img.onload = async () => {
                this.uploadedImage = {
                    file: file,
                    dataUrl: e.target.result,
                    width: img.width,
                    height: img.height
                };

                const previewImage = document.getElementById('preview-image');
                const previewSection = document.getElementById('preview-section');
                const resultsSection = document.getElementById('results-section');
                
                if (previewImage) previewImage.src = e.target.result;
                if (previewSection) previewSection.style.display = 'block';
                if (resultsSection) resultsSection.style.display = 'none';
                
                console.log('âœ… ì´ë¯¸ì§€ ì—…ë¡œë“œ ì™„ë£Œ:', file.name);
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    // === ë¸Œëœë“œ ê°€ë°© íŠ¹í™” íŠ¹ì§• ì¶”ì¶œ ===
    
    // 1. ë¸Œëœë“œ íŒ¨í„´ ê°ì§€ (ëª¨ë…¸ê·¸ë¨, í€¼íŒ… ë“±)
    detectBrandPatterns(imageElement) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 200;
        canvas.height = 200;
        ctx.drawImage(imageElement, 0, 0, 200, 200);
        
        const imageData = ctx.getImageData(0, 0, 200, 200);
        const data = imageData.data;
        
        const patterns = {
            repetitive: 0,      // ë°˜ë³µ íŒ¨í„´ (LV ëª¨ë…¸ê·¸ë¨)
            diagonal: 0,        // ëŒ€ê°ì„  íŒ¨í„´ (Chanel í€¼íŒ…)
            horizontal: 0,      // ìˆ˜í‰ íŒ¨í„´ (Gucci ìŠ¤íŠ¸ë¼ì´í”„)
            textured: 0,        // í…ìŠ¤ì²˜ (Prada ì‚¬í”¼ì•„ë…¸)
            smooth: 0           // ë§¤ë„ëŸ¬ìš´ í‘œë©´ (Hermes)
        };
        
        // FFTë¥¼ ì´ìš©í•œ ì£¼ê¸°ì„± ë¶„ì„ (ê°„ë‹¨í•œ ë²„ì „)
        const rowVariances = [];
        const colVariances = [];
        
        for (let y = 0; y < 200; y++) {
            let rowMean = 0;
            for (let x = 0; x < 200; x++) {
                const idx = (y * 200 + x) * 4;
                rowMean += (data[idx] + data[idx+1] + data[idx+2]) / 3;
            }
            rowMean /= 200;
            
            let rowVar = 0;
            for (let x = 0; x < 200; x++) {
                const idx = (y * 200 + x) * 4;
                const gray = (data[idx] + data[idx+1] + data[idx+2]) / 3;
                rowVar += Math.pow(gray - rowMean, 2);
            }
            rowVariances.push(rowVar / 200);
        }
        
        // ì£¼ê¸°ì„± ê²€ì¶œ
        let periodicCount = 0;
        for (let i = 10; i < rowVariances.length - 10; i += 10) {
            const window = rowVariances.slice(i, i + 10);
            const mean = window.reduce((a, b) => a + b) / 10;
            const isUniform = window.every(v => Math.abs(v - mean) < mean * 0.3);
            if (isUniform) periodicCount++;
        }
        
        patterns.repetitive = periodicCount / 10;
        
        // ëŒ€ê°ì„  íŒ¨í„´ ê°ì§€ (Sobel í•„í„° ì‘ìš©)
        let diagonalEdges = 0;
        for (let y = 1; y < 199; y++) {
            for (let x = 1; x < 199; x++) {
                const idx = (y * 200 + x) * 4;
                const tl = data[((y-1) * 200 + (x-1)) * 4];
                const br = data[((y+1) * 200 + (x+1)) * 4];
                const tr = data[((y-1) * 200 + (x+1)) * 4];
                const bl = data[((y+1) * 200 + (x-1)) * 4];
                
                const diag1 = Math.abs(tl - br);
                const diag2 = Math.abs(tr - bl);
                
                if (diag1 > 30 || diag2 > 30) diagonalEdges++;
            }
        }
        patterns.diagonal = diagonalEdges / (198 * 198);
        
        // í…ìŠ¤ì²˜ ë³µì¡ë„
        let textureComplexity = 0;
        for (let y = 1; y < 199; y++) {
            for (let x = 1; x < 199; x++) {
                const idx = (y * 200 + x) * 4;
                const center = data[idx];
                const neighbors = [
                    data[((y-1) * 200 + x) * 4],
                    data[((y+1) * 200 + x) * 4],
                    data[(y * 200 + (x-1)) * 4],
                    data[(y * 200 + (x+1)) * 4]
                ];
                
                const diff = neighbors.reduce((sum, n) => sum + Math.abs(center - n), 0);
                textureComplexity += diff;
            }
        }
        patterns.textured = textureComplexity / (198 * 198 * 255 * 4);
        
        // ë§¤ë„ëŸ¬ì›€ ì •ë„ (ë‚®ì€ ë¶„ì‚°)
        patterns.smooth = 1 - patterns.textured;
        
        return patterns;
    }
    
    // 2. ê¸ˆì† ì¥ì‹ ê°ì§€
    detectMetalHardware(imageElement) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 150;
        canvas.height = 150;
        ctx.drawImage(imageElement, 0, 0, 150, 150);
        
        const imageData = ctx.getImageData(0, 0, 150, 150);
        const data = imageData.data;
        
        let goldPixels = 0;
        let silverPixels = 0;
        let metallicPixels = 0;
        
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            // ê¸ˆìƒ‰ ê°ì§€ (í™©ê¸ˆë¹›)
            if (r > 180 && g > 140 && b < 100 && r > g && g > b) {
                goldPixels++;
            }
            
            // ì€ìƒ‰ ê°ì§€ (íšŒìƒ‰ë¹› ê¸ˆì†)
            if (Math.abs(r - g) < 20 && Math.abs(g - b) < 20 && r > 160 && r < 220) {
                silverPixels++;
            }
            
            // ì¼ë°˜ ê¸ˆì†ì„± (ë†’ì€ ëª…ë„, ë‚®ì€ ì±„ë„)
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const saturation = max === 0 ? 0 : (max - min) / max;
            
            if (max > 180 && saturation < 0.3) {
                metallicPixels++;
            }
        }
        
        const totalPixels = 150 * 150;
        return {
            hasGold: goldPixels / totalPixels > 0.005,
            hasSilver: silverPixels / totalPixels > 0.005,
            metalRatio: metallicPixels / totalPixels,
            dominantMetal: goldPixels > silverPixels ? 'gold' : 'silver'
        };
    }
    
    // 3. ë¡œê³ /ë¸Œëœë“œ ë§ˆí¬ ì˜ì—­ ê°ì§€
    detectLogoRegions(imageElement) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 200;
        canvas.height = 200;
        ctx.drawImage(imageElement, 0, 0, 200, 200);
        
        const imageData = ctx.getImageData(0, 0, 200, 200);
        
        // ê³ ëŒ€ë¹„ ì˜ì—­ ì°¾ê¸° (ë¡œê³ ëŠ” ë³´í†µ ê³ ëŒ€ë¹„)
        const contrastMap = this.calculateContrastMap(imageData);
        
        // ì¤‘ì•™ ì˜ì—­ì— ê³ ëŒ€ë¹„ ë¶€ë¶„ì´ ìˆëŠ”ì§€ í™•ì¸
        let centerHighContrast = 0;
        const centerX = 100, centerY = 100, radius = 50;
        
        for (let y = centerY - radius; y < centerY + radius; y++) {
            for (let x = centerX - radius; x < centerX + radius; x++) {
                if (contrastMap[y * 200 + x] > 0.7) {
                    centerHighContrast++;
                }
            }
        }
        
        return {
            hasCenterLogo: centerHighContrast > (Math.PI * radius * radius * 0.05),
            contrastScore: contrastMap.reduce((a, b) => a + b) / contrastMap.length
        };
    }
    
    // ëŒ€ë¹„ ë§µ ê³„ì‚°
    calculateContrastMap(imageData) {
        const width = imageData.width;
        const height = imageData.height;
        const data = imageData.data;
        const contrastMap = [];
        
        for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
                const idx = (y * width + x) * 4;
                const center = (data[idx] + data[idx+1] + data[idx+2]) / 3;
                
                let maxDiff = 0;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const nIdx = ((y + dy) * width + (x + dx)) * 4;
                        const neighbor = (data[nIdx] + data[nIdx+1] + data[nIdx+2]) / 3;
                        maxDiff = Math.max(maxDiff, Math.abs(center - neighbor));
                    }
                }
                
                contrastMap.push(maxDiff / 255);
            }
        }
        
        return contrastMap;
    }
    
    // 4. í–¥ìƒëœ ìƒ‰ìƒ ë¶„ì„ (ë¸Œëœë“œ ì‹œê·¸ë‹ˆì²˜ ìƒ‰ìƒ)
    analyzeBrandColors(imageElement) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 100;
        canvas.height = 100;
        ctx.drawImage(imageElement, 0, 0, 100, 100);
        
        const imageData = ctx.getImageData(0, 0, 100, 100);
        const data = imageData.data;
        
        const colorClusters = {
            brown: 0,
            black: 0,
            beige: 0,
            red: 0,
            green: 0,
            navy: 0,
            orange: 0,
            gold: 0,
            white: 0
        };
        
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            // ë¸Œëœë“œë³„ ì‹œê·¸ë‹ˆì²˜ ìƒ‰ìƒ ë§¤ì¹­
            if (r > 80 && r < 140 && g > 50 && g < 100 && b > 20 && b < 70) {
                colorClusters.brown++;  // LV, Hermes
            } else if (r < 40 && g < 40 && b < 40) {
                colorClusters.black++;  // Chanel, Prada
            } else if (r > 200 && g > 180 && b > 140) {
                colorClusters.beige++;  // LV, Chanel
            } else if (r > 180 && g < 80 && b < 80) {
                colorClusters.red++;    // Gucci
            } else if (r < 100 && g > 80 && b < 100) {
                colorClusters.green++;  // Gucci
            } else if (r < 50 && g < 50 && b > 80) {
                colorClusters.navy++;   // Prada
            } else if (r > 200 && g > 120 && g < 180 && b < 100) {
                colorClusters.orange++; // Hermes
            } else if (r > 180 && g > 140 && b < 100) {
                colorClusters.gold++;   // ê¸ˆì† ì¥ì‹
            } else if (r > 200 && g > 200 && b > 200) {
                colorClusters.white++;
            }
        }
        
        // ì •ê·œí™”
        const total = 100 * 100;
        for (let color in colorClusters) {
            colorClusters[color] = colorClusters[color] / total;
        }
        
        return colorClusters;
    }
    
    // 5. ORB íŠ¹ì§•ì  ì¶”ì¶œ (ê°„ë‹¨í•œ ë²„ì „)
    extractORBKeypoints(imageElement) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 128;
        canvas.height = 128;
        ctx.drawImage(imageElement, 0, 0, 128, 128);
        
        const imageData = ctx.getImageData(0, 0, 128, 128);
        const gray = this.toGrayscale(imageData);
        
        // Harris ì½”ë„ˆ ê²€ì¶œ (ORBì˜ ê¸°ë°˜)
        const corners = this.detectHarrisCorners(gray, 128, 128);
        
        // ìƒìœ„ 50ê°œ íŠ¹ì§•ì  ì„ íƒ
        corners.sort((a, b) => b.response - a.response);
        const keypoints = corners.slice(0, 50);
        
        // ê° íŠ¹ì§•ì  ì£¼ë³€ì˜ BRIEF ë””ìŠ¤í¬ë¦½í„° ê³„ì‚°
        const descriptors = keypoints.map(kp => {
            return this.computeBRIEFDescriptor(gray, kp.x, kp.y, 128, 128);
        });
        
        return {
            keypoints: keypoints,
            descriptors: descriptors,
            count: keypoints.length
        };
    }
    
    // Harris ì½”ë„ˆ ê²€ì¶œ
    detectHarrisCorners(gray, width, height) {
        const corners = [];
        const k = 0.04;
        
        for (let y = 5; y < height - 5; y++) {
            for (let x = 5; x < width - 5; x++) {
                let Ixx = 0, Iyy = 0, Ixy = 0;
                
                // 5x5 ìœˆë„ìš°ì—ì„œ ê·¸ë˜ë””ì–¸íŠ¸ ê³„ì‚°
                for (let wy = -2; wy <= 2; wy++) {
                    for (let wx = -2; wx <= 2; wx++) {
                        const idx = (y + wy) * width + (x + wx);
                        
                        const dx = (gray[idx + 1] || 0) - (gray[idx - 1] || 0);
                        const dy = (gray[idx + width] || 0) - (gray[idx - width] || 0);
                        
                        Ixx += dx * dx;
                        Iyy += dy * dy;
                        Ixy += dx * dy;
                    }
                }
                
                // Harris ì‘ë‹µ ê³„ì‚°
                const det = Ixx * Iyy - Ixy * Ixy;
                const trace = Ixx + Iyy;
                const response = det - k * trace * trace;
                
                if (response > 1000) {  // ì„ê³„ê°’
                    corners.push({ x, y, response });
                }
            }
        }
        
        return corners;
    }
    
    // BRIEF ë””ìŠ¤í¬ë¦½í„° ê³„ì‚°
    computeBRIEFDescriptor(gray, x, y, width, height) {
        const descriptor = [];
        const pattern = [
            [-2, -2], [2, 2], [-1, 3], [3, -1],
            [0, -3], [0, 3], [-3, 0], [3, 0],
            [-2, 1], [1, -2], [2, -1], [-1, 2]
        ];
        
        for (let i = 0; i < pattern.length; i += 2) {
            const x1 = Math.max(0, Math.min(width - 1, x + pattern[i][0]));
            const y1 = Math.max(0, Math.min(height - 1, y + pattern[i][1]));
            const x2 = Math.max(0, Math.min(width - 1, x + pattern[i + 1][0]));
            const y2 = Math.max(0, Math.min(height - 1, y + pattern[i + 1][1]));
            
            const val1 = gray[y1 * width + x1] || 0;
            const val2 = gray[y2 * width + x2] || 0;
            
            descriptor.push(val1 > val2 ? 1 : 0);
        }
        
        return descriptor;
    }
    
    // ê·¸ë ˆì´ìŠ¤ì¼€ì¼ ë³€í™˜
    toGrayscale(imageData) {
        const data = imageData.data;
        const gray = [];
        
        for (let i = 0; i < data.length; i += 4) {
            gray.push(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
        }
        
        return gray;
    }
    
    // 6. ìŠ¤í‹°ì¹˜ íŒ¨í„´ ê°ì§€
    detectStitchPatterns(imageElement) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 150;
        canvas.height = 150;
        ctx.drawImage(imageElement, 0, 0, 150, 150);
        
        const imageData = ctx.getImageData(0, 0, 150, 150);
        const edges = this.detectEdges(imageData);
        
        // ì§ì„  íŒ¨í„´ ê°ì§€ (Hough ë³€í™˜ ê°„ì†Œí™”)
        let horizontalLines = 0;
        let verticalLines = 0;
        let diagonalLines = 0;
        
        // ìˆ˜í‰ì„  ê°ì§€
        for (let y = 0; y < 150; y++) {
            let consecutiveEdges = 0;
            for (let x = 0; x < 150; x++) {
                if (edges[y * 150 + x] > 0.5) {
                    consecutiveEdges++;
                    if (consecutiveEdges > 30) {
                        horizontalLines++;
                        break;
                    }
                } else {
                    consecutiveEdges = 0;
                }
            }
        }
        
        // ìˆ˜ì§ì„  ê°ì§€
        for (let x = 0; x < 150; x++) {
            let consecutiveEdges = 0;
            for (let y = 0; y < 150; y++) {
                if (edges[y * 150 + x] > 0.5) {
                    consecutiveEdges++;
                    if (consecutiveEdges > 30) {
                        verticalLines++;
                        break;
                    }
                } else {
                    consecutiveEdges = 0;
                }
            }
        }
        
        return {
            hasStitching: (horizontalLines + verticalLines) > 5,
            stitchDensity: (horizontalLines + verticalLines) / 300,
            pattern: horizontalLines > verticalLines ? 'horizontal' : 'vertical'
        };
    }
    
    // ì—£ì§€ ê²€ì¶œ (Canny ê°„ì†Œí™”)
    detectEdges(imageData) {
        const width = imageData.width;
        const height = imageData.height;
        const data = imageData.data;
        const edges = [];
        
        for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
                const idx = (y * width + x) * 4;
                
                // Sobel ì—°ì‚°ì
                const gx = 
                    -1 * data[((y-1) * width + (x-1)) * 4] +
                     1 * data[((y-1) * width + (x+1)) * 4] +
                    -2 * data[(y * width + (x-1)) * 4] +
                     2 * data[(y * width + (x+1)) * 4] +
                    -1 * data[((y+1) * width + (x-1)) * 4] +
                     1 * data[((y+1) * width + (x+1)) * 4];
                
                const gy = 
                    -1 * data[((y-1) * width + (x-1)) * 4] +
                    -2 * data[((y-1) * width + x) * 4] +
                    -1 * data[((y-1) * width + (x+1)) * 4] +
                     1 * data[((y+1) * width + (x-1)) * 4] +
                     2 * data[((y+1) * width + x) * 4] +
                     1 * data[((y+1) * width + (x+1)) * 4];
                
                const magnitude = Math.sqrt(gx * gx + gy * gy);
                edges.push(magnitude / 1020);  // ì •ê·œí™”
            }
        }
        
        return edges;
    }
    
    // í†µí•© íŠ¹ì§• ì¶”ì¶œ
    async extractAllFeatures(imageElement) {
        // ê¸°ë³¸ íŠ¹ì§•
        const aspectRatio = imageElement.width / imageElement.height;
        
        // ë¸Œëœë“œ íŠ¹í™” íŠ¹ì§•
        const brandPatterns = this.detectBrandPatterns(imageElement);
        const metalHardware = this.detectMetalHardware(imageElement);
        const logoRegions = this.detectLogoRegions(imageElement);
        const brandColors = this.analyzeBrandColors(imageElement);
        const orbFeatures = this.extractORBKeypoints(imageElement);
        const stitchPatterns = this.detectStitchPatterns(imageElement);
        
        // ë¸Œëœë“œ ì¶”ì •
        const estimatedBrand = this.estimateBrand(
            brandColors,
            brandPatterns,
            metalHardware,
            aspectRatio
        );
        
        return {
            basic: { aspectRatio },
            patterns: brandPatterns,
            metal: metalHardware,
            logo: logoRegions,
            colors: brandColors,
            orb: orbFeatures,
            stitch: stitchPatterns,
            brand: estimatedBrand
        };
    }
    
    // ë¸Œëœë“œ ì¶”ì •
    estimateBrand(colors, patterns, metal, aspectRatio) {
        const scores = {};
        
        // Louis Vuitton ì ìˆ˜
        scores.louis_vuitton = 0;
        if (colors.brown > 0.2 && colors.beige > 0.1) scores.louis_vuitton += 0.3;
        if (patterns.repetitive > 0.5) scores.louis_vuitton += 0.4;
        if (metal.hasGold) scores.louis_vuitton += 0.2;
        if (Math.abs(aspectRatio - 1.2) < 0.3) scores.louis_vuitton += 0.1;
        
        // Chanel ì ìˆ˜
        scores.chanel = 0;
        if (colors.black > 0.3) scores.chanel += 0.3;
        if (patterns.diagonal > 0.3) scores.chanel += 0.4;
        if (metal.hasGold || metal.hasSilver) scores.chanel += 0.2;
        if (Math.abs(aspectRatio - 1.4) < 0.3) scores.chanel += 0.1;
        
        // Gucci ì ìˆ˜
        scores.gucci = 0;
        if (colors.green > 0.05 && colors.red > 0.05) scores.gucci += 0.4;
        if (patterns.horizontal > 0.2) scores.gucci += 0.3;
        if (metal.hasGold) scores.gucci += 0.2;
        
        // Prada ì ìˆ˜
        scores.prada = 0;
        if (colors.black > 0.3 || colors.navy > 0.2) scores.prada += 0.3;
        if (patterns.textured > 0.4) scores.prada += 0.3;
        if (metal.hasSilver) scores.prada += 0.2;
        if (patterns.smooth < 0.3) scores.prada += 0.2;
        
        // Hermes ì ìˆ˜
        scores.hermes = 0;
        if (colors.orange > 0.1 || colors.brown > 0.2) scores.hermes += 0.3;
        if (patterns.smooth > 0.6) scores.hermes += 0.4;
        if (metal.hasGold) scores.hermes += 0.2;
        
        // ìµœê³  ì ìˆ˜ ë¸Œëœë“œ ì°¾ê¸°
        let maxScore = 0;
        let estimatedBrand = 'unknown';
        
        for (const [brand, score] of Object.entries(scores)) {
            if (score > maxScore && score > 0.3) {  // ìµœì†Œ ì„ê³„ê°’ 0.3
                maxScore = score;
                estimatedBrand = brand;
            }
        }
        
        return {
            name: estimatedBrand,
            confidence: maxScore,
            scores: scores
        };
    }
    
    // ìœ ì‚¬ë„ ê³„ì‚°
    calculateSimilarity(features1, features2) {
        let similarity = 0;
        let weights = {
            aspectRatio: 0.05,
            patterns: 0.25,
            colors: 0.20,
            metal: 0.15,
            logo: 0.10,
            orb: 0.15,
            stitch: 0.05,
            brand: 0.05
        };
        
        // ë¸Œëœë“œê°€ ê°™ìœ¼ë©´ ê°€ì¤‘ì¹˜ ì¡°ì •
        if (features1.brand.name !== 'unknown' && 
            features1.brand.name === features2.brand.name) {
            weights.brand = 0.15;
            weights.patterns = 0.30;
            weights.colors = 0.25;
        }
        
        // 1. ì¢…íš¡ë¹„ ìœ ì‚¬ë„
        const aspectDiff = Math.abs(features1.basic.aspectRatio - features2.basic.aspectRatio);
        const aspectSim = 1 / (1 + aspectDiff * 2);
        similarity += aspectSim * weights.aspectRatio;
        
        // 2. íŒ¨í„´ ìœ ì‚¬ë„
        let patternSim = 0;
        for (const key in features1.patterns) {
            const diff = Math.abs(features1.patterns[key] - features2.patterns[key]);
            patternSim += (1 - diff);
        }
        patternSim /= Object.keys(features1.patterns).length;
        similarity += patternSim * weights.patterns;
        
        // 3. ìƒ‰ìƒ ìœ ì‚¬ë„
        let colorSim = 0;
        for (const color in features1.colors) {
            const diff = Math.abs(features1.colors[color] - features2.colors[color]);
            colorSim += (1 - diff);
        }
        colorSim /= Object.keys(features1.colors).length;
        similarity += colorSim * weights.colors;
        
        // 4. ê¸ˆì† ì¥ì‹ ìœ ì‚¬ë„
        let metalSim = 0;
        if (features1.metal.hasGold === features2.metal.hasGold) metalSim += 0.3;
        if (features1.metal.hasSilver === features2.metal.hasSilver) metalSim += 0.3;
        if (features1.metal.dominantMetal === features2.metal.dominantMetal) metalSim += 0.2;
        metalSim += (1 - Math.abs(features1.metal.metalRatio - features2.metal.metalRatio)) * 0.2;
        similarity += metalSim * weights.metal;
        
        // 5. ë¡œê³  ìœ ì‚¬ë„
        let logoSim = 0;
        if (features1.logo.hasCenterLogo === features2.logo.hasCenterLogo) logoSim += 0.5;
        logoSim += (1 - Math.abs(features1.logo.contrastScore - features2.logo.contrastScore)) * 0.5;
        similarity += logoSim * weights.logo;
        
        // 6. ORB íŠ¹ì§•ì  ë§¤ì¹­
        let orbSim = 0;
        if (features1.orb.descriptors.length > 0 && features2.orb.descriptors.length > 0) {
            let matches = 0;
            const threshold = 3;  // í•´ë° ê±°ë¦¬ ì„ê³„ê°’
            
            for (const desc1 of features1.orb.descriptors) {
                for (const desc2 of features2.orb.descriptors) {
                    let distance = 0;
                    for (let i = 0; i < desc1.length; i++) {
                        if (desc1[i] !== desc2[i]) distance++;
                    }
                    if (distance <= threshold) {
                        matches++;
                        break;
                    }
                }
            }
            
            orbSim = matches / Math.min(features1.orb.descriptors.length, features2.orb.descriptors.length);
        }
        similarity += orbSim * weights.orb;
        
        // 7. ìŠ¤í‹°ì¹˜ íŒ¨í„´ ìœ ì‚¬ë„
        let stitchSim = 0;
        if (features1.stitch.hasStitching === features2.stitch.hasStitching) stitchSim += 0.5;
        if (features1.stitch.pattern === features2.stitch.pattern) stitchSim += 0.3;
        stitchSim += (1 - Math.abs(features1.stitch.stitchDensity - features2.stitch.stitchDensity)) * 0.2;
        similarity += stitchSim * weights.stitch;
        
        // 8. ë¸Œëœë“œ ìœ ì‚¬ë„
        if (features1.brand.name !== 'unknown' && features2.brand.name !== 'unknown') {
            if (features1.brand.name === features2.brand.name) {
                similarity += weights.brand;
            } else {
                // ë‹¤ë¥¸ ë¸Œëœë“œë©´ í˜ë„í‹°
                similarity *= 0.7;
            }
        }
        
        return Math.max(0, Math.min(1, similarity));
    }

    async searchSimilarImages() {
        if (!this.uploadedImage) {
            alert('ë¨¼ì € ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.');
            return;
        }

        if (this.imageDatabase.length === 0) {
            alert('ì¸ë±ì‹±ëœ ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ì´ë¯¸ì§€ë¥¼ ì¸ë±ì‹±í•´ì£¼ì„¸ìš”.');
            return;
        }

        this.showLoading('ë¸Œëœë“œ ê°€ë°©ì„ ê²€ìƒ‰í•˜ëŠ” ì¤‘...');
        console.log('ğŸ” ê²€ìƒ‰ ì‹œì‘...');

        try {
            const img = document.getElementById('preview-image');
            const queryFeatures = await this.extractAllFeatures(img);
            
            console.log('ğŸ¯ ê°ì§€ëœ ë¸Œëœë“œ:', queryFeatures.brand.name, 
                       `(ì‹ ë¢°ë„: ${(queryFeatures.brand.confidence * 100).toFixed(1)}%)`);

            const results = this.imageDatabase.map((item) => {
                const similarity = this.calculateSimilarity(queryFeatures, item.features);
                return {
                    ...item,
                    similarity: similarity,
                    brandMatch: item.features.brand.name === queryFeatures.brand.name
                };
            });

            results.sort((a, b) => {
                // ë¸Œëœë“œ ì¼ì¹˜ ìš°ì„ , ê·¸ ë‹¤ìŒ ìœ ì‚¬ë„
                if (a.brandMatch !== b.brandMatch) {
                    return b.brandMatch - a.brandMatch;
                }
                return b.similarity - a.similarity;
            });

            const filteredResults = results.filter(r => r.similarity < 0.98);
            
            this.displayResults(filteredResults.slice(0, 30));
            
            console.log(`âœ… ê²€ìƒ‰ ì™„ë£Œ: ${filteredResults.length}ê°œ ê²°ê³¼`);

        } catch (error) {
            console.error('âŒ ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜:', error);
            alert('ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        } finally {
            this.hideLoading();
        }
    }

    displayResults(results) {
        const resultsGrid = document.getElementById('results-grid');
        const resultCount = document.getElementById('result-count');
        
        if (resultCount) resultCount.textContent = `(${results.length}ê°œ)`;
        if (!resultsGrid) return;
        
        resultsGrid.innerHTML = '';

        results.forEach((result, index) => {
            const resultItem = document.createElement('div');
            resultItem.className = 'result-item';
            
            const similarity = Math.round(result.similarity * 100);
            const brand = result.features.brand.name;
            const brandConf = Math.round(result.features.brand.confidence * 100);
            
            const img = document.createElement('img');
            img.className = 'result-image';
            img.alt = result.name;
            img.loading = 'lazy';
            
            this.loadResultImage(img, result.path, result.name);
            
            const infoDiv = document.createElement('div');
            infoDiv.className = 'result-info';
            
            const displayName = result.name.length > 30 
                ? result.name.substring(0, 27) + '...' 
                : result.name;
            
            let brandBadge = '';
            if (brand !== 'unknown') {
                const brandColors = {
                    'louis_vuitton': '#8B4513',
                    'chanel': '#000000',
                    'gucci': '#006400',
                    'prada': '#000080',
                    'hermes': '#FF8C00'
                };
                brandBadge = `<span style="background: ${brandColors[brand] || '#666'}; 
                                           color: white; 
                                           padding: 2px 6px; 
                                           border-radius: 3px; 
                                           font-size: 10px;">
                                ${brand.replace('_', ' ').toUpperCase()} ${brandConf}%
                              </span>`;
            }
            
            infoDiv.innerHTML = `
                <div class="result-filename" title="${result.name}">${displayName}</div>
                <div class="result-similarity">
                    ìœ ì‚¬ë„: <strong>${similarity}%</strong>
                    ${brandBadge}
                </div>
            `;
            
            resultItem.appendChild(img);
            resultItem.appendChild(infoDiv);
            
            resultItem.addEventListener('click', async () => {
                try {
                    await invoke('open_file_location', { path: result.path });
                } catch (error) {
                    console.error('íŒŒì¼ ìœ„ì¹˜ ì—´ê¸° ì‹¤íŒ¨:', error);
                }
            });

            resultsGrid.appendChild(resultItem);
        });

        const resultsSection = document.getElementById('results-section');
        if (resultsSection) resultsSection.style.display = 'block';
    }

    async loadResultImage(imgElement, filePath, fileName) {
        try {
            let normalizedPath = filePath.replace(/\\/g, '/');
            const cleanFileName = fileName.trim();
            
            if (cleanFileName.includes(' ')) {
                const dirPath = normalizedPath.substring(0, normalizedPath.lastIndexOf('/'));
                normalizedPath = `${dirPath}/${cleanFileName}`;
            }
            
            const assetUrl = convertFileSrc(normalizedPath);
            imgElement.src = assetUrl;
            
            imgElement.onerror = async () => {
                try {
                    const imageData = await readBinaryFile(filePath);
                    const ext = fileName.split('.').pop().toLowerCase();
                    const mimeTypes = {
                        'jpg': 'image/jpeg',
                        'jpeg': 'image/jpeg',
                        'png': 'image/png',
                        'gif': 'image/gif',
                        'webp': 'image/webp'
                    };
                    
                    const blob = new Blob([imageData], { type: mimeTypes[ext] || 'image/jpeg' });
                    const url = URL.createObjectURL(blob);
                    
                    imgElement.src = url;
                    
                    imgElement.onload = () => {
                        setTimeout(() => URL.revokeObjectURL(url), 1000);
                    };
                } catch (error) {
                    console.error(`ì´ë¯¸ì§€ ì½ê¸° ì‹¤íŒ¨: ${filePath}`, error);
                    imgElement.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZSIvPjx0ZXh0IHRleHQtYW5jaG9yPSJtaWRkbGUiIHg9IjEwMCIgeT0iMTAwIiBzdHlsZT0iZmlsbDojYWFhO2ZvbnQtd2VpZ2h0OmJvbGQ7Zm9udC1zaXplOjEzcHg7Zm9udC1mYW1pbHk6QXJpYWwsSGVsdmV0aWNhLHNhbnMtc2VyaWY7ZG9taW5hbnQtYmFzZWxpbmU6Y2VudHJhbCI+ë¡œë“œ ì‹¤íŒ¨</text></svg>';
                }
            };
        } catch (error) {
            console.error(`ì´ë¯¸ì§€ ì²˜ë¦¬ ì˜¤ë¥˜: ${filePath}`, error);
        }
    }

    async selectFolder() {
        try {
            const selected = await open({
                directory: true,
                multiple: false,
                title: 'ì´ë¯¸ì§€ í´ë” ì„ íƒ'
            });

            if (selected) {
                await this.indexFolder(selected);
            }
        } catch (error) {
            console.error('í´ë” ì„ íƒ ì˜¤ë¥˜:', error);
        }
    }

    async indexFolder(folderPath) {
        this.showLoading('ë¸Œëœë“œ ê°€ë°© ì´ë¯¸ì§€ë¥¼ ë¶„ì„í•˜ëŠ” ì¤‘...');

        try {
            const entries = await readDir(folderPath, { recursive: true });
            const imageFiles = entries.filter(entry => {
                if (!entry.name) return false;
                const ext = entry.name.toLowerCase().split('.').pop();
                return ['jpg', 'jpeg', 'png', 'gif', 'webp'].includes(ext);
            });

            const folderPathEl = document.getElementById('folder-path');
            const imageCountEl = document.getElementById('image-count');
            const folderInfoEl = document.getElementById('folder-info');
            
            if (folderPathEl) folderPathEl.textContent = folderPath;
            if (imageCountEl) imageCountEl.textContent = imageFiles.length;
            if (folderInfoEl) folderInfoEl.style.display = 'block';

            if (imageFiles.length === 0) {
                alert('ì„ íƒí•œ í´ë”ì— ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.');
                this.hideLoading();
                return;
            }

            const progressEl = document.getElementById('indexing-progress');
            const resultsEl = document.getElementById('index-results');
            
            if (progressEl) progressEl.style.display = 'block';
            if (resultsEl) resultsEl.style.display = 'none';

            const newDatabase = [];
            const totalImages = imageFiles.length;
            let processedCount = 0;
            let errorCount = 0;
            
            // ë¸Œëœë“œë³„ í†µê³„
            const brandStats = {};

            const batchSize = 3;  // ë³µì¡í•œ íŠ¹ì§• ì¶”ì¶œë¡œ ì¸í•´ ë°°ì¹˜ í¬ê¸° ì¶•ì†Œ
            
            for (let i = 0; i < imageFiles.length; i += batchSize) {
                const batch = imageFiles.slice(i, i + batchSize);
                
                await Promise.all(batch.map(async (file) => {
                    try {
                        const imageData = await readBinaryFile(file.path);
                        const blob = new Blob([imageData]);
                        const imageUrl = URL.createObjectURL(blob);

                        const img = new Image();
                        await new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = reject;
                            img.src = imageUrl;
                        });

                        const features = await this.extractAllFeatures(img);
                        
                        // ë¸Œëœë“œ í†µê³„ ì—…ë°ì´íŠ¸
                        const brand = features.brand.name;
                        if (!brandStats[brand]) brandStats[brand] = 0;
                        brandStats[brand]++;
                        
                        newDatabase.push({
                            path: file.path,
                            name: file.name || 'Unknown',
                            features: features
                        });

                        URL.revokeObjectURL(imageUrl);
                        processedCount++;

                    } catch (error) {
                        console.error(`ì´ë¯¸ì§€ ì²˜ë¦¬ ì‹¤íŒ¨: ${file.name}`, error);
                        errorCount++;
                    }
                }));

                const progress = Math.round((Math.min(i + batchSize, totalImages) / totalImages) * 100);
                const fillEl = document.getElementById('progress-fill');
                const textEl = document.getElementById('progress-text');
                
                if (fillEl) fillEl.style.width = `${progress}%`;
                if (textEl) textEl.textContent = `${Math.min(i + batchSize, totalImages)} / ${totalImages}`;

                await new Promise(resolve => setTimeout(resolve, 50));
            }

            this.imageDatabase = newDatabase;
            await this.saveDatabase();

            const fillEl = document.getElementById('progress-fill');
            const textEl = document.getElementById('progress-text');
            
            if (fillEl) fillEl.style.width = '100%';
            if (textEl) textEl.textContent = `${totalImages} / ${totalImages}`;
            
            // ë¸Œëœë“œ í†µê³„ ì¶œë ¥
            console.log('ğŸ“Š ë¸Œëœë“œ ë¶„ì„ ê²°ê³¼:');
            for (const [brand, count] of Object.entries(brandStats)) {
                const percentage = ((count / processedCount) * 100).toFixed(1);
                console.log(`  ${brand}: ${count}ê°œ (${percentage}%)`);
            }
            
            setTimeout(() => {
                if (progressEl) progressEl.style.display = 'none';
                if (resultsEl) resultsEl.style.display = 'block';
                
                const countEl = document.getElementById('indexed-count');
                if (countEl) countEl.textContent = processedCount;
                
                if (errorCount > 0) {
                    alert(`âœ… ì¸ë±ì‹± ì™„ë£Œ!\nì„±ê³µ: ${processedCount}ê°œ\nì‹¤íŒ¨: ${errorCount}ê°œ`);
                } else {
                    console.log(`âœ… ì¸ë±ì‹± ì™„ë£Œ: ${processedCount}ê°œ ì„±ê³µ`);
                }
            }, 500);

        } catch (error) {
            console.error('ì¸ë±ì‹± ì˜¤ë¥˜:', error);
            alert('ì¸ë±ì‹± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        } finally {
            this.hideLoading();
        }
    }

    async saveDatabase() {
        try {
            const dbData = {
                version: 8,
                timestamp: Date.now(),
                appVersion: this.version,
                featureVersion: 'brand_specialized',
                data: this.imageDatabase
            };
            
            await this.storage.setItem('brandDatabase', dbData);
            console.log(`ğŸ’¾ ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥ ì™„ë£Œ (v${dbData.version})`);
        } catch (error) {
            console.error('âŒ ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥ ì‹¤íŒ¨:', error);
        }
    }

    async loadDatabase() {
        try {
            const stored = await this.storage.getItem('brandDatabase');
            
            if (stored) {
                if (stored.version === 8 && stored.featureVersion === 'brand_specialized') {
                    this.imageDatabase = stored.data || [];
                    console.log(`ğŸ“‚ ${this.imageDatabase.length}ê°œì˜ ì´ë¯¸ì§€ ë¡œë“œë¨`);
                } else {
                    console.log('âš ï¸ ì´ì „ ë²„ì „ ë°ì´í„°ë² ì´ìŠ¤. ì¬ì¸ë±ì‹± í•„ìš”');
                    this.imageDatabase = [];
                    await this.storage.clear();
                }
            }
        } catch (error) {
            console.error('âŒ ë°ì´í„°ë² ì´ìŠ¤ ë¡œë“œ ì‹¤íŒ¨:', error);
            this.imageDatabase = [];
        }
    }

    showLoading(text = 'ì²˜ë¦¬ ì¤‘...') {
        const overlay = document.getElementById('loading-overlay');
        if (overlay) {
            const loadingText = overlay.querySelector('.loading-text');
            if (loadingText) loadingText.textContent = text;
            overlay.style.display = 'flex';
        }
    }

    hideLoading() {
        const overlay = document.getElementById('loading-overlay');
        if (overlay) {
            overlay.style.display = 'none';
        }
    }
}

// ì•± ì´ˆê¸°í™”
document.addEventListener('DOMContentLoaded', () => {
    console.log('ğŸš€ DOM ë¡œë“œ ì™„ë£Œ, ì•± ì´ˆê¸°í™” ì‹œì‘...');
    
    const app = new BrandBagSearchSystem();
    
    window.brandApp = {
        version: () => {
            console.log(`ë²„ì „: v${app.version}`);
            console.log(`DB í¬ê¸°: ${app.imageDatabase.length} ê°œ`);
            console.log(`íŠ¹ì§•: ë¸Œëœë“œ íŒ¨í„´, ê¸ˆì† ì¥ì‹, ë¡œê³ , ORB, ìŠ¤í‹°ì¹˜`);
        },
        clearDB: async () => {
            app.imageDatabase = [];
            await app.storage.clear();
            console.log('âœ… DB ì´ˆê¸°í™” ì™„ë£Œ');
        },
        testFeatures: async () => {
            if (app.uploadedImage) {
                const img = document.getElementById('preview-image');
                const features = await app.extractAllFeatures(img);
                console.log('íŠ¹ì§• ì¶”ì¶œ ê²°ê³¼:', features);
                console.log(`ì¶”ì • ë¸Œëœë“œ: ${features.brand.name} (${(features.brand.confidence * 100).toFixed(1)}%)`);
            } else {
                console.log('ë¨¼ì € ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ì„¸ìš”');
            }
        },
        getBrandStats: () => {
            const stats = {};
            app.imageDatabase.forEach(item => {
                const brand = item.features.brand.name;
                if (!stats[brand]) stats[brand] = 0;
                stats[brand]++;
            });
            console.log('ë¸Œëœë“œ í†µê³„:', stats);
            return stats;
        }
    };
    
    console.log('%cğŸ‘œ Brand Bag Search v8.0 ì´ˆê¸°í™” ì™„ë£Œ!', 'color: #ff6b6b; font-size: 16px; font-weight: bold;');
    console.log('%cë¸Œëœë“œ ê°€ë°© íŠ¹í™” ê²€ìƒ‰ ì‹œìŠ¤í…œ', 'color: #666; font-style: italic;');
    console.log('íŠ¹ì§•:');
    console.log('  âœ… ë¸Œëœë“œë³„ íŒ¨í„´ ì¸ì‹ (ëª¨ë…¸ê·¸ë¨, í€¼íŒ…, ì‚¬í”¼ì•„ë…¸ ë“±)');
    console.log('  âœ… ê¸ˆì† ì¥ì‹ ê°ì§€ (ê¸ˆ/ì€)');
    console.log('  âœ… ë¡œê³ /ë¸Œëœë“œ ë§ˆí¬ ì˜ì—­ ê°ì§€');
    console.log('  âœ… ë¸Œëœë“œ ì‹œê·¸ë‹ˆì²˜ ìƒ‰ìƒ ë¶„ì„');
    console.log('  âœ… ORB íŠ¹ì§•ì  ë§¤ì¹­');
    console.log('  âœ… ìŠ¤í‹°ì¹˜ íŒ¨í„´ ê°ì§€');
    console.log('ì§€ì› ë¸Œëœë“œ:');
    console.log('  Louis Vuitton, Chanel, Gucci, Prada, Hermes');
    console.log('ì½˜ì†” ëª…ë ¹ì–´:');
    console.log('  brandApp.version() - ë²„ì „ ì •ë³´');
    console.log('  brandApp.clearDB() - DB ì´ˆê¸°í™”');
    console.log('  brandApp.testFeatures() - íŠ¹ì§• ì¶”ì¶œ í…ŒìŠ¤íŠ¸');
    console.log('  brandApp.getBrandStats() - ë¸Œëœë“œ í†µê³„');
});